#!/usr/bin/env node

// TODO
// make .ok a folder
// that contains a global config and individual info for all apps

var fs      = require('fs'),
    exec    = require('child_process').exec,
    path    = require('path'),
    argv    = require('optimist').argv

var userHome,
    configPath,
    config = {}

var tasks = {

    create: function (appname) {
        if (!appname) return
        // setup bare git repo
        var repo = config.git_dir + '/' + appname + '.git',
            work = config.srv_dir + '/' + appname

        if (fs.existsSync(repo) || fs.existsSync(work)) {
            console.error('Error: an app with that name already exists.')
            return
        }
        
        fs.mkdirSync(repo)

        exec('git --git-dir ' + repo + ' --bare init', function (err) {
            if (err) {
                console.error(err)
            } else {
                console.log('create bare repo at ' + repo)
                // add post-update hook
                createHook(appname, repo, work)
                // create working copy
                exec('git clone ' + repo + ' ' + work, function (err) {
                    console.log(err ? err : 'create empty working copy at ' + work)
                })
            }
        })
    },

    rm: function (appname) {
        if (!appname) return
        console.log('Really delete app \'' + appname + '\'? (y/n)')
        process.stdin.resume()
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', function (input) {
            process.stdin.pause()
            if (input === 'y\n') {
                var repo = config.git_dir + '/' + appname + '.git',
                    work = config.srv_dir + '/' + appname
                exec('rm -rf ' + repo + ' ' + work, function (err) {
                    if (err) {
                        console.error(err)
                    } else {
                        console.log('rm ' + repo)
                        console.log('rm ' + work)
                    }
                })
            }
        })
        
    },

    list: function () {

        var apps = findApps()

        // see if they are running
        exec('forever list', function (err, stdout) {
            if (err) {
                console.err(err)
            } else {
                var output = []

                apps.forEach(function (app) {
                    var port = sniffPort(app),
                        status
                    if (stdout.match(new RegExp(config.srv_dir + '/' + app + '/app.js', 'i'))) {
                        status = ' - \u001b[32mON\u001b[0m'
                    } else {
                        status = ' - \u001b[31mOFF\u001b[0m'
                    }
                    output.push(app + port + status)
                })

                console.log()
                output.forEach(function (a) {
                    console.log('- ' + a)
                })
                console.log()

            }
        })
    },

    set: function (key, val) {
        if (config[key] && val) {
            // test if path exists
            if (key === 'git_dir' || key === 'srv_dir') {
                var dir = path.resolve(process.cwd(), val)
                if (!fs.existsSync(dir)) {
                    console.error('Error: path doesn\'t exist.')
                    return
                } else {
                    // changing git_dir should modify
                    // the git remote origin of all existing apps
                    if (key === 'git_dir') {

                    }

                    // changing srv_dir should modify
                    // the git pull cd location
                    // in existing repo's hooks/post-update script
                    if (key === 'srv_dir') {

                    }
                }
            }

            config[key] = val
            writeConfig()
        }
    },

    // proxy these to forever?

    start: function (appname) {

    },

    startall: function () {

    },

    restart: function (appname) {

    },

    restartall: function () {

    },

    stop: function (appname) {

    },

    stopall: function () {

    }

}



// Find user home first

exec('echo $HOME', function (err, stdout) {
    userHome = stdout.replace(/\n/g, '')
    configPath = userHome + '/.okconfig'
    if (fs.existsSync(configPath)) {
        // load existing config file
        config = JSON.parse(fs.readFileSync(configPath, 'utf-8'))
        doCommand()
    } else {
        // otherwise init a new config
        config = {
            git_dir: userHome,
            srv_dir: userHome
        }
        writeConfig(function (err) {
            if (err) {
                console.log(err)
            } else {
                console.log('created new .okconfig in ' + userHome)
                logConfig()
                doCommand(true)
            }
        })
    }
})

function doCommand (init) {

    checkConfigOverride()

    var command = argv._[0]

    if (!command && !init) {
        logConfig()
        return
    }

    if (tasks[command]) {
        tasks[command](argv._[1], argv._[2])
    } else {
        if (command) {
            console.error('unknown command ' + command)
        }
    }

}

// options to override config file
function checkConfigOverride () {

    if (argv.git_dir && typeof argv.git_dir === 'string') {
        console.log('using git_dir: ' + argv.git_dir);
        config.git_dir = argv.git_dir
    }

    if (argv.srv_dir && typeof argv.srv_dir === 'string') {
        console.log('using srv_dir: ' + argv.srv_dir);
        config.srv_dir = argv.srv_dir
    }

}

function createHook (appname, repo, work) {

    var hook = repo + '/hooks/post-update'
    var data = fs.readFileSync(__dirname + '/../hooks/post-update', 'utf-8')

    data = data.replace(/\{\{srv_dir\}\}/g, work)

    fs.writeFile(hook, data, function (err) {
        if (err) {
            console.error(err)
        } else {
            console.log('create post-update hook')
            exec('chmod a+x ' + hook)
        }
    })

}

function formatJSON (val) {
    var retval = '',
        str = val,
        pos = 0,
        strLen = str.length,
        indentStr = '    ',
        newLine = '\n',
        char = ''
    
    for (var i=0; i<strLen; i++) {
        char = str.substring(i, i + 1)
        if (char === '}' || char === ']') {
            retval = retval + newLine
            pos = pos - 1
            
            for (var j=0; j<pos; j++) {
                retval = retval + indentStr
            }
        }
        if (char === ':') char = char + ' '
        retval = retval + char;
        if (char === '{' || char === '[' || char === ',') {
            retval = retval + newLine
            if (char === '{' || char === '[') {
                pos = pos + 1
            }
            for (var k=0; k<pos; k++) {
                retval = retval + indentStr
            }
        }
    }
    return retval
}

function writeConfig (callback) {
    fs.writeFile(configPath, formatJSON(JSON.stringify(config)), callback)
}

function logConfig () {
    for (var op in config) {
        console.log(op + ': ' + config[op])
    }
}

function findApps () {

    var repos,
        works,
        apps = []

    // get repos
    repos = fs.readdirSync(config.git_dir).filter(function (r) {
        return r.match(/\b.*\.git\b/g)
    })

    if (!repos) {
        console.log('No apps found.')
        return
    }

    // get working copies
    works = fs.readdirSync(config.srv_dir)

    // make sure an app has both the git repo and the working copy
    repos.forEach(function (r) {
        var name = r.slice(0, -4)
        if (works.indexOf(name) !== -1) {
            apps.push(name)
        }
    })

    return apps
}

// attempt to sniff the port of the app
// TODO also check if they're running (forever list | grep ...)
function sniffPort (appname) {
    var appFile = config.srv_dir + '/' + appname + '/app.js'
    if (fs.existsSync(appFile)) {
        // sniff port
        var content = fs.readFileSync(appFile, 'utf-8'),
            port = content.match(/\.listen\(([0-9]+)\)/)[1]
        return port ? (' : ' + port) : ''
    } else {
        return ''
    }
}