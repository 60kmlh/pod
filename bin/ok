#!/usr/bin/env node

var fs      = require('fs'),
    exec    = require('child_process').exec,
    path    = require('path'),
    argv    = require('optimist').argv

var userHome,
    configPath,
    config = {}

var tasks = {

    create: function (appname) {
        if (!appname) return
        // setup bare git repo
        var repo = config.git_dir + '/' + appname + '.git',
            work = config.srv_dir + '/' + appname

        if (fs.existsSync(repo) || fs.existsSync(work)) {
            console.error('Error: an app with that name already exists.')
            return
        }
        
        fs.mkdirSync(repo)

        exec('git --git-dir ' + repo + ' --bare init', function (err) {
            if (err) {
                console.error(err)
            } else {
                console.log('create bare repo at ' + repo)
                // add post-update hook
                createHook(appname, repo, work)
                // create working copy
                exec('git clone ' + repo + ' ' + work, function (err) {
                    console.log(err ? err : 'create empty working copy at ' + work)
                })
            }
        })
    },

    rm: function (appname) {
        if (!appname) return
        console.log('Really delete app \'' + appname + '\'? (y/n)')
        process.stdin.resume()
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', function (input) {
            process.stdin.pause()
            if (input === 'y\n') {
                var repo = config.git_dir + '/' + appname + '.git',
                    work = config.srv_dir + '/' + appname
                exec('rm -rf ' + repo + ' ' + work, function (err) {
                    if (err) {
                        console.error(err)
                    } else {
                        console.log('rm ' + repo)
                        console.log('rm ' + work)
                    }
                })
            }
        })
        
    },

    list: function () {

        var repos,
            works,
            apps = []

        // get repos
        repos = fs.readdirSync(config.git_dir).filter(function (r) {
            return r.match(/\b.*\.git\b/g)
        })

        if (!repos) {
            console.log('No apps found.')
            return
        }

        // get working copies
        works = fs.readdirSync(config.srv_dir)

        // make sure an app has both the git repo and the working copy
        repos.forEach(function (r) {
            var name = r.slice(0, -4)
            if (works.indexOf(name) !== -1) {
                apps.push(name)
            }
        })

        // see if they are running
        exec('forever list', function (err, stdout) {
            if (!err) {
                var output = []

                apps.forEach(function (app) {

                    var withPort = inspectApp(app)

                    if (stdout.match(app + '/app.js')) {
                        output.push(withPort + ' - \u001b[32mrunning\u001b[0m')
                    } else {
                        output.push(withPort)
                    }

                })

                // output
                console.log('Existing apps:')
                output.forEach(function (a) {
                    console.log(a)
                })

            } else {
                console.error(err)
            }
        })
    },

    set: function (key, val) {
        if (config[key] && val) {
            // test if path exists
            if (key === 'git_dir' || key === 'srv_dir') {
                var dir = path.resolve(process.cwd(), val)
                if (!fs.existsSync(dir)) {
                    console.error('Error: path doesn\'t exist.')
                    return
                } else {
                    // TODO

                    // changing git_dir should modify
                    // the git remote origin of all existing apps

                    // changing srv_dir should modify
                    // the git pull cd location
                    // in existing repo's hooks/post-update script
                }
            }

            config[key] = val
            writeConfig()
        }
    },

    // proxy these to forever

    start: function (appname) {

    },

    startall: function () {

    },

    restart: function (appname) {

    },

    restartall: function () {

    },

    stop: function (appname) {

    },

    stopall: function () {

    }

}



// Find user home first

exec('echo $HOME', function (err, stdout) {
    userHome = stdout.replace(/\n/g, '')
    configPath = userHome + '/.okconfig'
    if (fs.existsSync(configPath)) {
        // load existing config file
        config = JSON.parse(fs.readFileSync(configPath, 'utf-8'))
        doCommand()
    } else {
        // otherwise init a new config
        config = {
            git_dir: userHome,
            srv_dir: userHome
        }
        writeConfig(function (err) {
            if (err) {
                console.log(err)
            } else {
                console.log('created new .okconfig in ' + userHome)
                logConfig()
                doCommand(true)
            }
        })
    }
})

function doCommand (init) {

    checkConfigOverride()

    var command = argv._[0]

    if (!command && !init) {
        logConfig()
        return
    }

    if (tasks[command]) {
        tasks[command](argv._[1], argv._[2])
    } else {
        if (command) {
            console.error('unknown command ' + command)
        }
    }

}

// options to override config file
function checkConfigOverride () {

    if (argv.git_dir && typeof argv.git_dir === 'string') {
        console.log('using git_dir: ' + argv.git_dir);
        config.git_dir = argv.git_dir
    }

    if (argv.srv_dir && typeof argv.srv_dir === 'string') {
        console.log('using srv_dir: ' + argv.srv_dir);
        config.srv_dir = argv.srv_dir
    }

}

function createHook (appname, repo, work) {

    var hook = repo + '/hooks/post-update'
    var data = fs.readFileSync(__dirname + '/../hooks/post-update', 'utf-8')

    data = data.replace(/\{\{srv_dir\}\}/g, work)

    fs.writeFile(hook, data, function (err) {
        if (err) {
            console.error(err)
        } else {
            console.log('create post-update hook')
            exec('chmod a+x ' + hook)
        }
    })

}

function formatJSON (val) {
    var retval = '',
        str = val,
        pos = 0,
        strLen = str.length,
        indentStr = '    ',
        newLine = '\n',
        char = ''
    
    for (var i=0; i<strLen; i++) {
        char = str.substring(i, i + 1)
        if (char === '}' || char === ']') {
            retval = retval + newLine
            pos = pos - 1
            
            for (var j=0; j<pos; j++) {
                retval = retval + indentStr
            }
        }
        if (char === ':') char = char + ' '
        retval = retval + char;
        if (char === '{' || char === '[' || char === ',') {
            retval = retval + newLine
            if (char === '{' || char === '[') {
                pos = pos + 1
            }
            for (var k=0; k<pos; k++) {
                retval = retval + indentStr
            }
        }
    }
    return retval
}

function writeConfig (callback) {
    fs.writeFile(configPath, formatJSON(JSON.stringify(config)), callback)
}

function logConfig () {
    for (var op in config) {
        console.log(op + ': ' + config[op])
    }
}

// attempt to sniff the port of the app
// TODO also check if they're running (forever list | grep ...)
function inspectApp (name) {
    var appFile = config.srv_dir + '/' + name + '/app.js'
    if (fs.existsSync(appFile)) {
        // sniff port
        var content = fs.readFileSync(appFile, 'utf-8'),
            port = content.match(/\.listen\(([0-9]+)\)/)[1]
        return '- ' + name + ' (' + port + ')'
    } else {
        return '- ' + name
    }
}