#!/usr/bin/env node
// TODO use forever-monitor programatically!!

var fs      = require('fs'),
    exec    = require('child_process').exec,
    path    = require('path'),
    argv    = require('optimist').argv,
    cwd     = process.cwd()

var userHome,
    configPath,
    config = {},
    runningStatus = null

var tasks = {

    create: function (appname) {
        if (!appname) return
        
        var repo = config.dir + '/repos/' + appname + '.git',
            work = config.dir + '/apps/' + appname,
            log = config.dir + '/logs/' + appname

        if (fs.existsSync(repo) || fs.existsSync(work)) {
            warn('an app with that name already exists.')
            return
        }

        // create log folder
        fs.mkdir(log, function (err) {
            if (err) {
                warn(err)
            } else {
                console.log('create logs dir at' + log)
            }
        })
        
        // setup bare git repo
        fs.mkdirSync(repo)
        exec('git --git-dir ' + repo + ' --bare init', function (err) {
            if (err) {
                warn(err)
            } else {
                console.log('create bare repo at ' + repo)
                // add post-update hook
                createHook(appname, repo, work)
                // create working copy
                exec('git clone ' + repo + ' ' + work, function (err) {
                    if (err) {
                        warn(err)
                    } else {
                        console.log('create empty working copy at ' + work)
                    }
                })
            }
        })

    },

    rm: function (appname) {

        if (!appname) return

        var repo = config.dir + '/repos/' + appname + '.git',
            work = config.dir + '/apps/' + appname,
            log = config.dir + '/logs/' + appname

        if (!fs.existsSync(repo) && !fs.existsSync(work)) {
            warn('app does not exist')
            return
        }

        prompt('Really delete app \'' + appname + '\'? (y/n)', function (res) {
            if (res === 'y') {
                // stop it first
                tasks.stop(appname)
                exec('rm -rf ' + repo + ' ' + work + ' ' + log, function (err) {
                    if (err) {
                        warn(err)
                    } else {
                        console.log('Deleted app: ' + appname)
                    }
                })
            }
        })
        
    },

    list: function () {

        var apps = findApps()

        if (!apps.length) {
            console.log('No apps found.')
            return
        }

        // see if they are running
        exec('forever list', function (err, stdout) {
            if (err) {
                warn(err)
            } else {
                var output = []

                apps.forEach(function (app) {
                    var port = sniffPort(app),
                        status
                    if (stdout.match(new RegExp(config.dir + '/apps/' + app + '/app.js', 'i'))) {
                        status = ' - \u001b[32mON\u001b[0m'
                    } else {
                        status = ' - \u001b[31mOFF\u001b[0m'
                    }
                    output.push(app + port + status)
                })

                output.forEach(function (a) {
                    console.log('âš‘ ' + a)
                })

            }
        })
    },

    set: function (key, val) {
        if (config[key] && val) {
            // test if path exists
            if (key === 'dir') {
                val = path.resolve(cwd, val)
                if (!fs.existsSync(val) || !isDir(val)) {
                    warn('invalid directory path.')
                    return
                }
            }

            config[key] = val
            writeConfig()
        }
    },

    // proxy these to forever

    start: function (appname) {
        if (!appname) return

        var script = config.dir + '/apps/' + appname + '/app.js',
            logDir = config.dir + '/logs/' + appname

        if (!fs.existsSync(script)) {
            warn('app.js not found.')
            return
        }

        // have to make sure it's running only once
        // forever -m 1 seems to have problems
        exec('forever list | grep ' + script, function (err, stdout) {
            if (err && err.code === 1) {
                exec('NODE_ENV=production forever start -a -m 5'
                    + '-l ' + logDir + '/forever.log '
                    + '-o ' + logDir + '/stdout.log '
                    + script, handle)
            } else {
                console.log(appname + ' already running.')
            }
        })
    },

    startall: function () {
        var apps = findApps()
        apps.forEach(tasks.start)
    },

    restart: function (appname) {
        if (!appname) return
        var script = config.dir + '/apps/' + appname + '/app.js'
        exec('forever restart ' + script, handle)
    },

    restartall: function () {
        exec('forever restartall', handle)
    },

    stop: function (appname) {
        if (!appname) return
        var script = config.dir + '/apps/' + appname + '/app.js'
        exec('forever stop ' + script, handle)
    },

    stopall: function () {
        exec('forever stopall', handle)
    }

}



// INIT

exec('echo $HOME', function (err, stdout) {
    userHome = stdout.replace(/\n/g, '')
    configPath = userHome + '/.okconfig'
    if (fs.existsSync(configPath)) {
        // load existing config file
        config = JSON.parse(fs.readFileSync(configPath, 'utf-8'))
        doCommand()
    } else {
        // otherwise init a new config
        console.log('No .okconfig found.')

        prompt('Where do you want OK to keep all its stuff?', function (res) {
            res = path.resolve(cwd, res)
            if (fs.existsSync(res) && isDir(res)) {
                config.dir = res
                writeConfig(function () {
                    console.log('created new .okconfig in ' + userHome)
                    makeDirs()
                    doCommand()
                })
            } else {
                console.log('invalid path.')
            }
        })
        
        
                    
    }
})

function makeDirs () {
    var apps = config.dir + '/apps',
        repos = config.dir + '/repos'
        logs = config.dir + '/logs'
    if (!fs.existsSync(apps)) fs.mkdirSync(apps)
    if (!fs.existsSync(repos)) fs.mkdirSync(repos)
    if (!fs.existsSync(logs)) fs.mkdirSync(logs)
}

function doCommand () {

    var command = argv._[0]

    if (!command) {
        logConfig()
        return
    }

    if (tasks[command]) {
        tasks[command](argv._[1], argv._[2])
    } else {
        if (command) {
            warn('unknown command ' + command)
        }
    }

}

// TODO make this read all existing hooks in ../hooks
function createHook (appname, repo, work) {

    var hook = repo + '/hooks/post-update'
    var data = fs.readFileSync(__dirname + '/../hooks/post-update', 'utf-8')

    data = data
        .replace(/\{\{ok_dir\}\}/g, config.dir)
        .replace(/\{\{app\}\}/g, appname)

    fs.writeFile(hook, data, function (err) {
        if (err) {
            warn(err)
        } else {
            fs.chmodSync(hook, '0777')
        }
    })

}

function formatJSON (val) {
    var retval = '',
        str = val,
        pos = 0,
        strLen = str.length,
        indentStr = '    ',
        newLine = '\n',
        char = ''
    
    for (var i=0; i<strLen; i++) {
        char = str.substring(i, i + 1)
        if (char === '}' || char === ']') {
            retval = retval + newLine
            pos = pos - 1
            
            for (var j=0; j<pos; j++) {
                retval = retval + indentStr
            }
        }
        if (char === ':') char = char + ' '
        retval = retval + char;
        if (char === '{' || char === '[' || char === ',') {
            retval = retval + newLine
            if (char === '{' || char === '[') {
                pos = pos + 1
            }
            for (var k=0; k<pos; k++) {
                retval = retval + indentStr
            }
        }
    }
    return retval
}

function writeConfig (callback) {
    fs.writeFile(configPath, formatJSON(JSON.stringify(config)), function (err) {
        if (err) {
            warn(err)
        } else {
            if (callback) callback()
        }
    })
}

function logConfig () {
    for (var op in config) {
        console.log(op + ': ' + config[op])
    }
}

function findApps () {

    var repos,
        works,
        apps = []

    // get repos
    repos = fs.readdirSync(config.dir + '/repos').filter(function (r) {
        return r.match(/\b.*\.git\b/g)
    })

    if (!repos) {
        console.log('No apps found.')
        return
    }

    // get working copies
    works = fs.readdirSync(config.dir + '/apps')

    // make sure an app has both the git repo and the working copy
    repos.forEach(function (r) {
        var name = r.slice(0, -4)
        if (works.indexOf(name) !== -1) {
            apps.push(name)
        }
    })

    return apps
}

function sniffPort (appname) {
    var appFile = config.dir + '/apps/' + appname + '/app.js'
    if (fs.existsSync(appFile)) {
        // sniff port
        var content = fs.readFileSync(appFile, 'utf-8'),
            port = content.match(/\.listen\(([0-9]+)\)/)[1]
        return port ? (' : ' + port) : ''
    } else {
        return ''
    }
}

function warn (msg) {
    console.warn('\u001b[31merror\u001b[0m:   ' + msg)
}

function handle (err, stdout, stderr) {
    if (err) warn(err)
    if (stderr) console.log(stderr)
    console.log(stdout)
}

function prompt (msg, callback) {
    console.log(msg)
    process.stdin.resume()
    process.stdin.setEncoding('utf8')
    process.stdin.on('data', function (input) {
        process.stdin.pause()
        callback(input.replace(/\n/g, ''))
    })
}

function isDir (path) {
    return fs.statSync(path).isDirectory()
}