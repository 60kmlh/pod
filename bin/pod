#!/usr/bin/env node

// TODO:
// - make ~/.podconfig a folder and hold info for each app created
// - allow config for each app:
//   pod config appname --node_env=production --port=8888 --script=app.js

var fs      = require('fs'),
    exec    = require('child_process').exec,
    path    = require('path'),
    argv    = require('optimist').argv,
    colors  = require('colors'),
    cwd     = process.cwd()

// lazy load so commands that doesn't need it runs faster
var forever,
    foreverTasks = [
        'rm',
        'list',
        'procs',
        'start',
        'stop',
        'restart',
        'startall',
        'stopall',
        'restartall'
    ]

var config = {},
    configPath = process.env.HOME + '/.podconfig'

var pod = {

    help: function (topic) {

        var usage

        if (topic === 'config') {
            usage ='\n'
            + '  Usage:\n'
            + '\n'
            + '    config                    Print current global config\n'
            + '    config --key=value        Set a global config option\n'
            + '    config <app>              Print current config for the app'
            + '    config <app> --key=value  Set the app\'s config option\n'
            + '    config --reset            Reset all global options to default value\n'
            + '\n'
            + '  Global Options:\n'
            + '\n'
            + '    dir                       Directory to hold the repos, apps and logs\n'
            + '    editor                    The editor to use when editing hook scripts\n'
            + '    env                       Set process.env.NODE_ENV\n'
            + '    script                    The main script to look for in each app\n'
            + '\n'
            + '  App Options:\n'
            + '\n'
            + '    env                       Overrides global env\n'
            + '    script                    Overrides global script\n'
            + '    port                      Set process.env.PORT\n'
            + '                              If not set, will attempt to sniff port with regex\n'
        } else {
            usage = '\n'
            + ('  Pod - version ' + require('../package.json').version + '\n').cyan
            + '\n'
            + '  Usage: pod [command]\n'
            + '\n'
            + '  Commands:\n'
            + '\n'
            + '    create <app>            Create a new app\n'
            + '    rm <app>                Delete an app\n'
            + '    cleanlogs <app>         Clean up logs for an app\n'
            + '    edit <app>              Edit the app\'s post-receive hook\n'
            + '    list [-p]               List apps and status. [-p] = List processes\n'
            + '    start <app>             Start an app with forever\n'
            + '    stop <app>              Stop an app\n'
            + '    restart <app>           Restart an app, start if not already running\n'
            + '    startall                Start all apps not already running\n'
            + '    stopall                 Stop all apps\n'
            + '    restartall              Restart all running apps\n'
            + '    help                    You are reading it right now\n'
            + '    config [options]        Type ' +'pod help config'.cyan + ' for detailed usage\n'
        }

        console.log(usage)
    },

    config: function () {
        for (var op in config) {
            console.log(op.cyan + spaces(10 - op.length) + config[op])
        }
    },

    create: function (appname) {
        if (!appname) return
        
        var repo = config.dir + '/repos/' + appname + '.git',
            work = config.dir + '/apps/' + appname,
            logDir = config.dir + '/logs/' + appname

        if (fs.existsSync(repo) || fs.existsSync(work)) {
            warn('an app with that name already exists.')
            return
        }

        // create log folder
        fs.mkdir(logDir, function (err) {
            if (err) {
                console.error(err)
            } else {
                log('create logs dir at ' + logDir.yellow)
            }
        })
        
        // setup bare git repo
        fs.mkdirSync(repo)
        exec('git --git-dir ' + repo + ' --bare init', function (err) {
            if (err) {
                warn(err)
            } else {
                log('create bare repo at ' + repo.yellow)
                // add post-receive hook
                createHook(appname, repo, work)
                // create working copy
                exec('git clone ' + repo + ' ' + work, function (err) {
                    if (err) {
                        warn(err)
                    } else {
                        log('create empty working copy at ' + work.yellow)
                    }
                })
            }
        })

    },

    rm: function (appname) {

        if (!appname) return

        var repo = config.dir + '/repos/' + appname + '.git',
            work = config.dir + '/apps/' + appname,
            logDir = config.dir + '/logs/' + appname

        if (!fs.existsSync(repo) && !fs.existsSync(work)) {
            warn('cannot find app ' + appname.yellow)
            return
        }

        prompt('Really delete app \'' + appname + '\'? (y/n)', function (res) {
            if (res === 'y') {
                // stop it first
                pod.stop(appname)
                // fs.rmdir can't -rf
                exec('rm -rf ' + repo + ' ' + work + ' ' + logDir, function (err) {
                    if (err) {
                        warn(err)
                    } else {
                        log('deleted app: ' + appname.yellow)
                    }
                })
            }
        })
        
    },

    cleanlogs: function (appname) {
        var logDir = logDir = config.dir + '/logs/' + appname
        if (!fs.existsSync(logDir)) {
            warn('cannot find log directory for ' + appname)
            return
        }
        clean('forever.log')
        clean('stderr.log')
        clean('stdout.log')
        var total = 3
        function clean (file) {
            file = logDir + '/' + file
            fs.exists(file, function (exist) {
                if (exist) {
                    fs.writeFile(file, 'restart at ' + Date.now() + '\n', 'utf-8', function (err) {
                        if (!err) {
                            done()
                        } else {
                            warn(err)
                        }
                    })
                } else done()
            })
        }
        function done () {
            total--
            if (!total) log('cleaned logs for ' + appname.yellow)
        }
    },

    edit: function (appname) {
        if (!appname) return
        process.stdin.setRawMode(true)
        var p = require('child_process').spawn(config.editor, [config.dir + '/repos/' + appname + '.git/hooks/post-receive'], {
            customFds: [ 0, 1, 2 ]
        })
        p.on('exit', function () {
            process.stdin.setRawMode(false)
        })
    },

    list: function () {

        var apps = findApps()
        if (!apps.length) {
            console.log('no apps found.')
            return
        }

        if (argv.p) {
            forever.list(true, function (err, info) {
                console.log(info ? info : 'no processes found.')
            })
            return
        }

        forever.list(false, function (err, list) {
            if (err) {
                warn(err)
            } else {
                var longest = getLongestName(apps)
                apps.forEach(function (app) {
                    var script = config.dir + '/apps/' + app + '/' + config.appfile,
                        port = sniffPort(script),
                        status = isRunning(list, script) ? 'ON'.green : 'OFF'.red
                    console.log('âš‘ ' + app.yellow + spaces(longest - app.length) + ' - ' + status + port)
                })
            }
        })

    },

    set: function (key, val) {
        if (config[key] && val) {
            // test if path exists
            if (key === 'dir') {
                val = path.resolve(cwd, val)
                if (!fs.existsSync(val) || !isDir(val)) {
                    warn('invalid directory path.')
                    return
                }
            }

            config[key] = val
            writeConfig()
            console.log(key.cyan + ' set to ' + val.magenta)
        }
    },

    start: function (appname, list) {
        if (!appname) return

        var script = config.dir + '/apps/' + appname + '/' + config.appfile,
            logDir = config.dir + '/logs/' + appname

        if (!fs.existsSync(script)) {
            warn('cannot locate ' + appfile + ' for ' + appname.yellow)
            return
        }

        if (list && list.length) {
            run()
        } else {
            forever.list(false, function (err, procs) {
                if (err) {
                    warn(err)
                } else {
                    list = procs
                    run()
                }
            })
        }

        function run () {
            if (isRunning(list, script)) {
                console.log(appname + ' already running.')
            } else {
                forever.startDaemon(script, {
                    max: 3,
                    logFile: logDir + '/forever.log',
                    errFile: logDir + '/stderr.log',
                    outFile: logDir + '/stdout.log',
                    append: true
                })
                var port = sniffPort(script)
                log(appname.yellow + ' running' + (port ? (' on port' + port) : ''))
            }
        }
    },

    stop: function (appname) {
        if (!appname) return

        var script = config.dir + '/apps/' + appname + '/' + config.appfile,
            runner = forever.stop(script)

        runner.on('stop', function () {
            log(appname.yellow + ' stopped.')
        })

        runner.on('error', function () {
            log(appname.yellow + ' is not running.')
        })
    },

    restart: function (appname) {
        if (!appname) return

        var script = config.dir + '/apps/' + appname + '/' + config.appfile,
            runner = forever.restart(script)

        runner.on('restart', function () {
            log(appname.yellow + ' restarted.')
        })

        runner.on('error', function () {
            log(appname.yellow + ' is not running, starting instead...')
            pod.start(appname)
        })

    },

    startall: function () {
        forever.list(false, function (err, list) {
            if (err) {
                warn(err)
            } else {
                var apps = findApps()
                if (!apps.length) {
                    console.log('no apps found.')
                    return
                }
                apps.forEach(function (app) {
                    pod.start(app, list)
                })      
            }
        })
    },

    stopall: function () {
        var runner = forever.stopAll()
        runner.on('stopAll', function (processes) {
            if (processes && processes.length) {
                var appnameRE = new RegExp(config.dir + '/apps/(.+)/' + config.appfile)
                log('stopped:')
                processes.forEach(function (p) {
                    var match = p.file.match(appnameRE)
                    if (match) console.log('âš‘ ' + match[1].yellow)
                })
            } else {
                console.log('no app is running.');
            }
        })
        runner.on('error', function (err) {
            console.log('no app is running.')
        })
    },

    restartall: function () {
        var runner = forever.restartAll()
        runner.on('restartAll', function (processes) {
            if (processes && processes.length) {
                var appnameRE = new RegExp(config.dir + '/apps/(.+)/' + config.appfile)
                log('restarted:')
                processes.forEach(function (p) {
                    var match = p.file.match(appnameRE)
                    if (match) console.log('âš‘ ' + match[1].yellow)
                })
            } else {
                console.log('no app is running.');
            }
        })
        runner.on('error', function (err) {
            console.log('no app is running.')
        })
    }

}

// INIT
function init () {
    var mainConfig = configPath + '/global.json'
    if (fs.existsSync(mainConfig)) {
        config = JSON.parse(fs.readFileSync(mainConfig, 'utf-8'))
        parseCommand()
    } else {
        console.log('No global config file found.')
        initConfig()
    }
}

function initConfig () {
    prompt('Where do you want OK to keep all its stuff?', function (res) {
        res = path.resolve(cwd, res)
        if (fs.existsSync(res) && isDir(res)) {
            config.dir = res
            // default values
            config.script = 'app.js'
            config.editor = process.env.VISUAL || process.env.EDITOR || 'vi'
            config.env = 'development'

            writeConfig(function () {
                log('created global config file: ' + (process.env.HOME + '/.podconfig/global.json').yellow)
                var apps = config.dir + '/apps',
                    repos = config.dir + '/repos'
                    logs = config.dir + '/logs'
                if (!fs.existsSync(apps)) fs.mkdirSync(apps)
                if (!fs.existsSync(repos)) fs.mkdirSync(repos)
                if (!fs.existsSync(logs)) fs.mkdirSync(logs)
            })
        } else {
            console.log('invalid path.')
            initConfig()
        }
    })
}

function parseCommand () {

    var command = argv._[0] || 'help'

    if (pod[command]) {
        if (foreverTasks.indexOf(command) !== -1) {
            forever = require('forever/lib/forever')
        }
        pod[command](argv._[1], argv._[2])
    } else {
        if (command) {
            warn('unknown command ' + command.red)
        }
    }

}

// TODO make this read all existing hooks in ../hooks
function createHook (appname, repo, work) {

    var hook = repo + '/hooks/post-receive'
    var data = fs.readFileSync(__dirname + '/../hooks/post-receive', 'utf-8')
        .replace(/\{\{pod_dir\}\}/g, config.dir)
        .replace(/\{\{app\}\}/g, appname)

    fs.writeFile(hook, data, function (err) {
        if (err) {
            warn(err)
        } else {
            fs.chmodSync(hook, '0777')
        }
    })

}

function writeConfig (callback) {
    if (!fs.existsSync(configPath)) {
        fs.mkdirSync(configPath)
    }
    fs.writeFile(configPath + '/global.json', formatJSON(JSON.stringify(config)), function (err) {
        if (err) {
            warn(err)
        } else {
            if (callback) callback()
        }
    })
}

function findApps () {

    var repos,
        works,
        apps = []

    // get repos
    repos = fs.readdirSync(config.dir + '/repos').filter(function (r) {
        return r.match(/\b.*\.git\b/g)
    })

    if (!repos) {
        console.log('no apps found.')
        return
    }

    // get working copies
    works = fs.readdirSync(config.dir + '/apps')

    // make sure an app has both the git repo and the working copy
    repos.forEach(function (r) {
        var name = r.slice(0, -4)
        if (works.indexOf(name) !== -1) {
            apps.push(name)
        }
    })

    return apps
}

function sniffPort (script) {
    if (fs.existsSync(script)) {
        // sniff port
        var content = fs.readFileSync(script, 'utf-8'),
            port = content.match(/\.listen\(([0-9]+)\)/)[1]
        return port ? (' : ' + port) : ''
    } else {
        return ''
    }
}

function isRunning(list, script) {
    if (!list || !list.length) return false
    for (var i = 0, j = list.length; i < j; i++) {
        if (list[i].file === script) {
            return true
        }
    }
}

function isDir (path) {
    return fs.statSync(path).isDirectory()
}

function prompt (msg, callback) {
    console.log(msg)
    process.stdin.resume()
    process.stdin.setEncoding('utf8')
    process.stdin.on('data', function (input) {
        process.stdin.pause()
        callback(input.replace(/\n/g, ''))
    })
}

function log (msg) {
    console.log('[pod] '.green + msg)
}

function warn (msg) {
    console.warn('error: '.red + msg)
}

function spaces (length) {
    if (length < 0) return ''
    var ret = ''
    while (length--) {
        ret += ' '
    }
    return ret
}

function formatJSON (val) {
    var retval = '',
        str = val,
        pos = 0,
        strLen = str.length,
        indentStr = '    ',
        newLine = '\n',
        char = ''
    
    for (var i=0; i<strLen; i++) {
        char = str.substring(i, i + 1)
        if (char === '}' || char === ']') {
            retval = retval + newLine
            pos = pos - 1
            
            for (var j=0; j<pos; j++) {
                retval = retval + indentStr
            }
        }
        if (char === ':') char = char + ' '
        retval = retval + char;
        if (char === '{' || char === '[' || char === ',') {
            retval = retval + newLine
            if (char === '{' || char === '[') {
                pos = pos + 1
            }
            for (var k=0; k<pos; k++) {
                retval = retval + indentStr
            }
        }
    }
    return retval
}

function getLongestName (apps) {
    var longest = 0
    apps.forEach(function (a) {
        if (a.length > longest) longest = a.length
    })
    return longest
}

init()